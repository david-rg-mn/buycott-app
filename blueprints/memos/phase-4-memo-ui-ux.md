
20

50%
the border of a field shakes slightly (horizontal shake 3px left-right, 2 cycles, over 300ms) – a standardform error indication. - These little feedback animations should follow the tone: not goofy or excessive,just enough to acknowledge the event. - No Abrupt Changes: A principle: avoid hard cut changes in UIwithout transition, except when absolutely necessary (e.g. real-time map updates which might justappear). For anything in our control, prefer a fade or slide that lasts at least 50-100ms to cue the eye.Even something like a list resorting after applying a filter could fade the list out and in or items slide tonew spots rather than a sudden resort jump. -  Motion Consistency:  The user should perceive thesystem as having consistent physics. If one sheet slides up quickly, another similar sheet should notslide up slowly – they should match. Document typical times: e.g. Sheets slide: 300ms ease-out,  Tooltipsfade: 150ms ease-in-out,  Loading spinners appear/disappear: fade in 200ms, no fade out if replacing contentmaybe, etc. Developers should use these standard timings from a central place if possible (like havingduration constants). -  Platform Adaptation: If targeting iOS/Android, consider adapting to platformconventions subtly: e.g., perhaps use Cupertino-style page transition on iOS (slight slide) vs Material onAndroid. But if using Flutter’s Material design as baseline, it might be okay. The main thing is, it shouldfeel at home on device (e.g., maybe disable overscroll glow in dark mode – that blue glow that Androidshows on overscroll might clash, consider customizing it to teal or neutral).By adhering to these interaction guidelines, the app will feel polished and intentional. Every hover,click, and navigation has a predefined response, eliminating guesswork and preventing any odd orinconsistent behavior from creeping in.Strict Anti-Drift RulesTo maintain the integrity of the design, we set forth  anti-drift rules  – hard constraints to preventgradual deviation over time. These rules are to be enforced both in design reviews and via automatedchecks:❌ Prohibited Off-Brand Colors: No colors outside the defined palette may be introduced withoutdesign approval. This means no random hex values in code or design comps. Developers mustnot use system default widget colors (which might be blue, etc.) unless mapped to our tokens.For example, no bright reds or oranges for emphasis (aside from the semantic error/warningtokens). Even within the teal family, do not adjust hues arbitrarily – stick to the provided HEXcodes for consistency. If a new UI element seems to require a new color, it should bediscussed and a new token officially added rather than a one-off usage.❌ No Decorative Gradients: Gradients are not   part of Buycott’s standard UI, except the matchconfidence use-case. Do not use gradients for backgrounds, buttons, or randomly behind text.The dark steel blue-gray background is flat   (or at most a subtle radial shadow in map, but not acolor gradient) to keep the look clean. Accent areas should be flat color fills. This avoids acluttered or inconsistent look. If a designer feels a subtle gradient would enhance a background,it must be extremely subtle and still only use our existing colors (for example, a slight top-to-bottom shift from #142633 to #1B2E3C – both within our neutral range – could be allowed if itadds depth, but it should be discussed). Under no circumstance should multi-color or high-contrast gradients be introduced. The LinkedIn-inspired theme gradient (steel blue toteal) informed our palette but is not used as a literal background in the app’s UI without explicitdesign call.❌ No Bright/Light Surfaces in Dark Mode: All surfaces remain dark. Do not suddenly use awhite or light gray card in the dark theme – that would be jarring (the only exception might bean image or map tile which contains lighter tones by necessity, but that’s content, not UIchrome). Also avoid large solid areas of accent color as surfaces – e.g., a teal notification bannerspanning the width would be too bright; instead use a dark background with a left border or• 7• 1213• 19
icon in teal to convey the message. Bright surfaces ruin the dark mode aesthetic and can causeeye strain with high contrast transitions. Keep the overall luminance low.❌ Avoid Excessive Accent Usage (Accent Stacking): As discussed, do not place multiple accentelements together in a way that they compete. For example, a screen that already has a tealheader and teal primary button should not also have teal used for secondary icons or texts –those should be toned down to neutral. Only the primary interactive or highlighted elements getthe accent. This prevents an oversaturation where nothing stands out. In components, similarly,if a component (like a card) has an accent-colored element (say a percentage badge), the rest ofthe card (title, icon) should not also all be in accent. One accent highlight per component. If adeveloper finds multiple accent-colored widgets adjacent, they should reconsider the hierarchyand likely change some to neutral. Automated linting could catch if more than X instances ofaccent color appear in a single screen widget tree, though that’s complex; at least code reviewshould.❌ No Custom Fonts or Sizes: Don’t use unapproved font families or arbitrary font sizes. All textshould conform to the typographic scale. For instance, no random 15px or 17px text – it’s either16 or 14 as defined. No usage of fancy display fonts or icon fonts that aren’t part of the designsystem. If an engineer needs an icon, they should use the official icon set (or SF Symbols orMaterial Icons, styled to our color) but not use, say, an emoji or a random glyph with a differentstyle.❌ Preserve Spacing Consistency: Do not introduce odd spacing to “make something fit.” If anelement doesn’t fit within the grid, re-think the layout rather than use 5px margins. Everyelement added should respect the spacing tokens around it. A common drift is adding tinypadding to nudge something – this accumulates as inconsistency. Instead, adjust the layoutusing multiples of 8. The design system should be seen as a constraint system; violating itundermines the consistency.✅ Enforce with Tools: Use tools to keep things in check – style linting to catch hard-coded colors,automated UI tests to compare against approved designs (visual regression). For example, if apull request includes a color code not in our palette, it should be flagged automatically (Codexrule: search for “#” hex patterns in code and compare against allowed list). Similarly, if a text styleis created with a font size not in {12,14,16,20,24,32}, flag it. Over time, these rules preventunintended drift.In essence, these anti-drift rules boil down to  “follow the system, not personal preference.”  Anydeviation must go through the design system maintainers. By being strict, we ensure that six monthsfrom now, Buycott’s UI will still look like one coherent product, not a patchwork of styles. Each ruleabove is non-negotiable for developers and designers working on the project.Implementation & Enforcement NotesFinally, to ensure this design system is effectively realized in the product, here are guidelines forimplementation in Flutter and for automated enforcement:Flutter Implementation: Leverage Flutter’s theming capabilities to encode these tokens. Use acustom ThemeData where:ThemeData.brightness = Brightness.dark and set primaryColor, accentColor (ifusing Material legacy) or better, define a ColorScheme with primary = our teal, secondary =perhaps a variant if needed, surface = surface color, background = primary bg, error = error red,etc. This integrates our colors at the core.Extend ThemeData with custom fields if needed (Flutter allows extension via Theme.of(context).extension<YourThemeExt>()) for things like match colors or customradius values if not directly supported.• • • • • • • 20
Define TextTheme with our font sizes/weights. E.g., headline4 for H1 32px, headline5 forH2 24px, etc., mapping appropriately. Use GoogleFonts (or include the font asset) to get Inter, orif using system fonts, specify fallback family names.Global styles: set buttonTheme, inputDecorationTheme, etc. to use our colors and radius(for instance, input fields should have 8px radius and use accent for focused border).For spacing, you might create constants in a Dimensions class, since Flutter doesn’t have built-inspacing tokens concept.Component reuse: Build widgets that encapsulate these designs. For example, make a PrimaryButton widget that automatically uses the correct styling so that developers don’tinadvertently style each button differently. Same for Cards, perhaps a BuycottCard that hasthe correct padding and corner by default.Use Flutter’s Material 3 capabilities if possible, as it allows specifying many tokens (like outlinecolor, surface tint for elevation overlay, etc.) that we can align with our system.Codex/Automation Enforcement: We aim to use automated checks (maybe even AI assistants)to ensure compliance:Color checks: A script can parse Dart code for any Color( or hex strings and verify theybelong to the approved set. Only exceptions would be color definitions in the theme setup. Thiscatches any stray usage.Text style checks: Search for TextStyle usages where fontSize or fontWeight is set. Ensure theymatch token values or use theme references. For example, if TextStyle(fontSize: 15)appears, that’s not allowed. Similarly, if fontFamily is set to something not “Inter” or systemdefault, flag it.Widget usage: If we provide base widgets (like the PrimaryButton class), encourage usage ofthose. Codex could review that no raw ElevatedButton.styleFrom is used with customcolors – instead, Theme.of(context).colorScheme.primary should be referenced. Possiblyenforce by code review that design system widgets are used or theme is leveraged.Layout checks: Some drift is harder to catch with static analysis (e.g., 10px padding). But we canset guidelines: use only multiples of 8 in EdgeInsets. Perhaps a lint rule could be written thatchecks the literal padding values in code for %8==0. While not foolproof(EdgeInsets.symmetric(vertical:10,horizontal:8) might slip one value), it’s something to aim for.Developers can be educated to use EdgeInsets.all(16) from our constants instead ofmagic numbers.Design tokens centralization: All token values (colors, sizes, etc.) should be defined in oneplace (maybe a design_system.dart). This file can be the single source of truth. Codex canensure any changes to it are reviewed carefully and that usage throughout references it.Testing UI: We can create screenshot tests of key screens and use them to catch unintendedchanges. If someone accidentally changes a color or font, the test will show a difference. Documentation and Training: This spec should be available to all team members. Do regulardesign reviews for new features strictly comparing against these rules. If something new can’t beachieved with current tokens, that signals a need to officially extend the system (with new token)rather than a one-off solution.By marrying the design system with Flutter’s theming and using automated checks, we ensure thedesign is not just aspirational but actually enforced in the product. Every element on screen can betraced back to these specifications, guaranteeing a  pixel-perfect, brand-consistent, and accessibleexperience across the app.19 Web Design Principles for User-Centric Siteshttps://uxpilot.ai/blogs/web-design-principles• • • • • • • • • • • • • 123456789101121
